# design-pattern

GO 设计模式学习

### 分类

- 创建型模式
    - 处理对象创建的设计模式，根据实际情况使用合适的方法创建对象
- 结构型模式
    - 对象组合形成更大的结构
- 行为型模式
    - 处理对象之间的通信和交互

### `SOLD` 原则

- 单一功能
    - 一个类或者模块只负责一个职责
- 开闭原则
    - 软件本体对扩展开放对修改关闭
- 里氏替换
    - 派生类能够替代基类并且不影响程序的行为，子类应该继承父类的所有属性和行为
- 依赖倒置
    - 依赖于一个抽象而不是一个实例，面向接口编程
- 接口隔离
    - 一个类对另一个类的依赖建立在最小的接口上

# 创建型模式

### 简单工厂模式

它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类
简单工厂模式用于创建实例的方法是静态方法，因此简单工厂模式又被称为静态工厂模式

### 工厂方法模式

定义一个用于创建对象的接口，让子类决定实例化哪一个类，将实例化延迟到子类的实现

### 抽象工厂模式

提供一个接口用于创建一系列相关的对象，不需要指定具体的类，创建多个相互关联的对象，使得系统独立于具体的产品类，同时提供了易于扩展和替换的功能

### 建设者模式

如果构建的对象的参数特别多，有些参数是必需的有些是可选的，使用构建者模式，返回给客户一个完整的产品对象，无需关注对象包含的额外属性和组建方式
构建者模式将复杂的对象的构建和表示分离，使得同样的构建过程可以创建不同的表示

### 原型模式

创建一个对象和另一个对象完全相同，将克隆的过程委派给被克隆的实际对象，被克隆的对象叫做原型
客户端在不知道具体类的情况下，通过接口管理器获取新的的实例

### 单例模式

全局只有一个实例。它负责创建自己的对象
保证全局实例的唯一性，只能被初始化一次，适合全局共享一个实例，例如数据库实例，全局配置等

- 饿汉
    - 全局的单例实例在包被加载时创建
- 懒汉
    - 全局的单例实例在被使用时候创建

### `New`

创建和初始化结构体实例，通常用于封装结构体的创建过程，提供一个包级别的函数或者方法

### 函数选项模式

用于处理函数或者对象具有多个可选参数的情况，运行用户根据需求为函数传递不同参数选项参数，定制函数的行为
又被称为傻瓜模式，常常用于参数传递，一般用户和 `New` 模式配合使用

### 对象池模式

预先实例化一定数量的对象，在需要的时从池中获取对象并在使用完成之后归还，减少对象的创建和销毁次数

- 对象池
    - 管理和维护一组对象池实例，提供对象获取和对象归还
- 对象
    - 池中存储的具体对象，可以被获取和归还
- 客户端
    - 从池中获取对象并进行操作，完成操作之后归还对象

# 行为模式

### 中介者模式

减少对象之间的直接依赖关系，促进对象之间的松耦合，所有的对象不再彼此通信

- 中介
    - 定义一个接口和各个同事对象之间通信
- 具体中介者
    - 实现中介接口，协调各个同事对象之间的通信
- 同事类
    - 每个同事类都知道中介对象，并可以通讯

### 观察者模式

定义一对多的依赖关系，让多个观察者对象同时监听并接受被观察者的对象的状态变化

- 目标
    - 被观察者
        - `Vector`存放被观察者的容器，保证线程安全
        - `attach` 添加观察者
        - `detach` 删除观察者
        - `notify` 调用观察者对象方法
- 具体目标
    - 目标的子类，通常包含经常需要发生改变的数据，状态发生变化的时候通知观察者
- 观察者
    - 对观察目标改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法
- 具体观察者
    - 维护一个指向具体目标的引用，存储具体观察者有关的状态

### 命令模式

将请求以命令的方式包裹在对象里面，传递给调用对象，调用对象寻找匹配该命令的对象，将命令交给该对象执行（排队请求，记录命令运行日志）

- 执行顺序
    - 命令被包裹在请求对象中，传递给调用对象
    - 调用对象查找匹配该命令的对象，将该命令传递给匹配的对象
    - 对象执行传递过来的命令
- 组成
    - 命令接口
        - 命令抽象成一个接口，不同的命令执行不同的操作
    - 具体命令
        - 实现命令接口，包含实际执行操作的方法
    - 调用者
        - 请求的封装发送者，通过命令对象来执行请求，不会直接操作接收者，而是直接关联命令对象
    - 接收者
        - 真正执行命令的对象
    - 客户端
        - 创建调用者，具体命令类去执行命令

### 迭代器模式

提供一种方法来顺序访问一个聚合对象中的各个元素，而无需暴露内部实现方式。迭代器模式需要将迭代操作从聚合对象中分离出来，让客户端可以独立地遍历聚合对象中的元素

- 迭代器接口
    - 定义访问和遍历元素的方法
        - `Next`
        - `HashNext`
- 具体迭代器
    - 实现迭代器接口
        - 数据
        - 列表
- 聚合对象
    - 定义创建迭代器方法
- 具体聚合对象
    - 实现聚合对象接口
        - 具体数据结构的管理和遍历

### 模板方法模式

将一个类中能够公共使用的方法抽象到抽象类中实现，不能公共使用的方法作为抽象方法，强制子类实现

### 策略模式

定义一系列算法，将算法封装起来，使得它们可以相互替换。客户端可以动态的选择需要的算法

### 状态模式

主要解决复杂状态之间的转换问题，核心目的是设计一个状态机，使用状态的改变来驱动行为的变化

- 状态接口
    - 定义通用状态规范
        - 处理请求方法 `handle()`
- 状态实现
    - 具体状态实现类，根据系统环境用于表达环境的各种状态
- 系统环境
    - 持有状态接口引用和更新状态的方法

### 备忘录模式

允许将对象在不暴露其内部状态的情况下捕获并存储这些状态，后续可以恢复到先前的这些状态
程序运行时对象的状态随时可能发生改变，当修改其状态我们可以对其进行记录（浏览器前进后退，操作系统快照恢复等操作）

- 发起人
    - 创建备忘录对象，更具需要将当前对象保存到备忘录中或者恢复备忘录中的某个状态
- 备忘录
    - 用于存储发起人的内部状态，可以包含多个状态属性，提供读取和设置
- 管理者
    - 管理备忘录对象，但是不进行操作

### 解释器模式

定义一种语言的文法，提供一个解释器来解释该语言中的表达式。解释器模式将文法表示一个语法树，通过解释器逐个解释语法树，从而执行特定的程序
`Redis` 协议就是一个解释器模式实现，通过 `redis-cli` 可以发送各种指令给 `redis-server`，服务端解释执行之后返回的结果

- 抽象表达式
    - 定义解释器接口，用于解释表达式
- 终端表达式
    - 语言中的最小单位，实现抽象表达式接口
- 非终端表达式
    - 多个终端表达式组合而成

### 责任链模式

将一个请求从一个处理程序传递到另一个处理程序，直到找到能处理该请求的函数为止；通常是通过函数的闭包和链式调用实现的
审批流程

### 访问者模式

定义一些操作，应用于一个对象结构的元素，而不会改变类，执行的操作独立于对象结构
景点售票，提供不同的票价

- 抽象的访问者
    - 访问具体元素的接口
    - 提供一个访问操作
- 具体访问者
    - 实现抽象访问者声明的各个访问操作
- 抽象元素
    - 声明一个包含接受操作 `Accept()` 的接口，参数为访问对象
- 对象结构
    - 元素容器
    - 提供访问容器相关的方法

### 注册表模式

用于管理应用程序中的全局对象，服务或者模块，允许将对象注册到一个集中的注册表；方便管理和访问全局对象，同时可以实现对象的延迟加载和解耦

- 注册和检索
    - 将对象注册到一个全局的注册表中，并通过相应的键来检索和使用这些对象
- 延迟加载
- 解耦组件
    - 不同组件之间可以松耦合的进行对象注册和访问

常用于实现对全局对象的管理和访问

### 上下文模式

用于在应用程序中传递和管理请求间的各种数据和信息，通过上下文对象，可以在不同组件之间共享数据，状态和配置信息

- 数据共享
    - 不同组件之间传递和共享数据
- 解耦组件
    - 不同组件之间可以松耦合的进行通信
- 请求访问
    - 通常在请求周期内存在，用于传递请求参数，认证信息等

# 结构模式

### 外观模式

为复杂的系统提供一个简单统一的接口，简化对外访问

- 外观门面
    - 封装多个子系统，并将它们整合起来对外提供统一的访问接口
- 子系统
    - 隐藏在门面中，数量任意，对外部不可见
- 客户端
    - 访问门面提供的接口

### 适配器模式

将一个接口转换为客户端所期望的另一个接口，使得接口不兼容的类可以相互合作

将需要接入的设备协议数据转化为系统内部可以识别的统一数据结构

### 代理模式

为其他对象提供一种代理以控制对这个对象的访问

### 组合模式（复合模式）

主要应用在带有树状关系的业务场景，使得用户对单个对象和组合对象的使用具有一致性，客户端无需区分单个对象和组合对象

- 组件接口
    - 复合节点和叶节点的高层抽象，定义组件操作的接口标准
- 复合组件
    - 包含单个子组件对象的复合型组件接口中定义的方法
- 叶端组件
    - 不包含子组件的终端组件
- 客户端
    - 按所需要层级关系部署相关的对象并操作组件接口所定义的接口，可以遍历树结构上的所有组件

### 享元模式

从对象中提取出公共部分并创建享元对象，减少应用程序中对象的数量

- 单纯享元模式
    - 所有的享元类都可以共享
- 复合享元模式
    - 单纯享元类使用组合模式形成的复合享元类，本身不能共享，组成的单元可以

### 装饰器模式

不改变原有功能类的情况下，对其进行装饰，扩展；在原有功能上提供额外的特性

- 接口组件
    - 所有装饰器和被装饰器接口标准
- 组件实现
    - 需要被装饰的组件
- 装饰器
- 装饰器实现

### 桥接模式

将抽象的部分和实现的部分分离（电路接的不同器件）；通过对象之间的组合关系替代继承

# 同步模式

### 条件变量模式

用于线程和协程之间的同步和通信。在该模式中，一个或多个线程或协程等待某个特定的条件的变化，然会再继续执行其他操作。

- `Wait`
    - 一个线程或者协程等待某个条件满足，当条件不满足会阻塞当前线程或者协程

### 互斥锁模式

并发编程设计模式，用于实现线程和协程之间的互斥访问控制，使用锁或者互斥体来保护临界区域

### 监听器模式

并发编程设计模式，用于实现线程和协程之间的协作和资源共享。将数据和操作封到统一的抽象数据类型，实现对共享资源的控制和同步
核心为一个互斥锁和一个或者多个条件变量组成的数据结构

### 读写锁模式

管理共享资源的读写访问，使用在读多写少的场景中

- 读
    - 并发访问资源，读操作可以并发进行而不会互相干扰
- 写
    - 互斥锁，保证数据一致性

### 信号量模式

用于控制对共享资源的访问权限的并发设计模式，信号量可以用来限制同时访问某个资源的并发数量，从而避免资源过度利用和竞争条件
包括一个计数器和两个原子操作

- P 等待
    - 尝试获取资源，如果资源不可用会阻塞或者等待
- V 释放
    - 释放资源，增加计数器的值，唤起等到线程或者协程

# 并发模式

### 屏障模式

多个并行任务实现一组任务的同步，该模式将多个任务执行到一个屏障上，等所有任务到达之后再继续一起执行

### 有界并行模式

用于控制并发任务数量，避免系统资源被过度占用。限制同时执行的任务数量，任务会被分为多个批次去执行

### 广播模式

发布订阅的设计模式，用于再系统中广播消息和事件给多个接收者

