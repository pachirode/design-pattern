# design-pattern

GO 设计模式学习

### 分类

- 创建型模式
    - 处理对象创建的设计模式，根据实际情况使用合适的方法创建对象
- 结构型模式
    - 对象组合形成更大的结构
- 行为型模式
    - 处理对象之间的通信和交互

### `SOLD` 原则

- 单一功能
    - 一个类或者模块只负责一个职责
- 开闭原则
    - 软件本体对扩展开放对修改关闭
- 里氏替换
    - 派生类能够替代基类并且不影响程序的行为，子类应该继承父类的所有属性和行为
- 依赖倒置
    - 依赖于一个抽象而不是一个实例，面向接口编程
- 接口隔离
    - 一个类对另一个类的依赖建立在最小的接口上

# 创建型模式

### 简单工厂模式

它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类
简单工厂模式用于创建实例的方法是静态方法，因此简单工厂模式又被称为静态工厂模式

### 工厂方法模式

定义一个用于创建对象的接口，让子类决定实例化哪一个类，将实例化延迟到子类的实现

### 抽象工厂模式

提供一个接口用于创建一系列相关的对象，不需要指定具体的类，创建多个相互关联的对象，使得系统独立于具体的产品类，同时提供了易于扩展和替换的功能

### 建设者模式

如果构建的对象的参数特别多，有些参数是必需的有些是可选的，使用构建者模式，返回给客户一个完整的产品对象，无需关注对象包含的额外属性和组建方式
构建者模式将复杂的对象的构建和表示分离，使得同样的构建过程可以创建不同的表示

### 原型模式

创建一个对象和另一个对象完全相同，将克隆的过程委派给被克隆的实际对象，被克隆的对象叫做原型
客户端在不知道具体类的情况下，通过接口管理器获取新的的实例

### 单例模式

全局只有一个实例。它负责创建自己的对象
保证全局实例的唯一性，只能被初始化一次，适合全局共享一个实例，例如数据库实例，全局配置等

- 饿汉
    - 全局的单例实例在包被加载时创建
- 懒汉
    - 全局的单例实例在被使用时候创建

### `New`

创建和初始化结构体实例，通常用于封装结构体的创建过程，提供一个包级别的函数或者方法

### 函数选项模式

用于处理函数或者对象具有多个可选参数的情况，运行用户根据需求为函数传递不同参数选项参数，定制函数的行为
又被称为傻瓜模式，常常用于参数传递，一般用户和 `New` 模式配合使用

### 对象池模式

预先实例化一定数量的对象，在需要的时从池中获取对象并在使用完成之后归还，减少对象的创建和销毁次数

- 对象池
    - 管理和维护一组对象池实例，提供对象获取和对象归还
- 对象
    - 池中存储的具体对象，可以被获取和归还
- 客户端
    - 从池中获取对象并进行操作，完成操作之后归还对象

# 行为模式

### 中介者模式

减少对象之间的直接依赖关系，促进对象之间的松耦合，所有的对象不再彼此通信

- 中介
    - 定义一个接口和各个同事对象之间通信
- 具体中介者
    - 实现中介接口，协调各个同事对象之间的通信
- 同事类
    - 每个同事类都知道中介对象，并可以通讯

### 观察者模式

定义一对多的依赖关系，让多个观察者对象同时监听并接受被观察者的对象的状态变化

- 目标
    - 被观察者
        - `Vector`存放被观察者的容器，保证线程安全
        - `attach` 添加观察者
        - `detach` 删除观察者
        - `notify` 调用观察者对象方法
- 具体目标
    - 目标的子类，通常包含经常需要发生改变的数据，状态发生变化的时候通知观察者
- 观察者
    - 对观察目标改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法
- 具体观察者
    - 维护一个指向具体目标的引用，存储具体观察者有关的状态

### 命令模式

将请求以命令的方式包裹在对象里面，传递给调用对象，调用对象寻找匹配该命令的对象，将命令交给该对象执行（排队请求，记录命令运行日志）

- 执行顺序
  - 命令被包裹在请求对象中，传递给调用对象
  - 调用对象查找匹配该命令的对象，将该命令传递给匹配的对象
  - 对象执行传递过来的命令
- 组成
  - 命令接口
    - 命令抽象成一个接口，不同的命令执行不同的操作
  - 具体命令
    - 实现命令接口，包含实际执行操作的方法
  - 调用者
    - 请求的封装发送者，通过命令对象来执行请求，不会直接操作接收者，而是直接关联命令对象
  - 接收者
    - 真正执行命令的对象
  - 客户端
    - 创建调用者，具体命令类去执行命令