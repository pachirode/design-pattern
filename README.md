# design-pattern

GO 设计模式学习

### 分类

- 创建型模式
    - 处理对象创建的设计模式，根据实际情况使用合适的方法创建对象
- 结构型模式
    - 对象组合形成更大的结构
- 行为型模式
    - 处理对象之间的通信和交互

### `SOLD` 原则

- 单一功能
    - 一个类或者模块只负责一个职责
- 开闭原则
    - 软件本体对扩展开放对修改关闭
- 里氏替换
    - 派生类能够替代基类并且不影响程序的行为，子类应该继承父类的所有属性和行为
- 依赖倒置
    - 依赖于一个抽象而不是一个实例，面向接口编程
- 接口隔离
    - 一个类对另一个类的依赖建立在最小的接口上

# 创建型模式

### 简单工厂模式

它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类
简单工厂模式用于创建实例的方法是静态方法，因此简单工厂模式又被称为静态工厂模式

### 工厂方法模式

定义一个用于创建对象的接口，让子类决定实例化哪一个类，将实例化延迟到子类的实现

### 抽象工厂模式

提供一个接口用于创建一系列相关的对象，不需要指定具体的类，创建多个相互关联的对象，使得系统独立于具体的产品类，同时提供了易于扩展和替换的功能

### 建设者模式

如果构建的对象的参数特别多，有些参数是必需的有些是可选的，使用构建者模式，返回给客户一个完整的产品对象，无需关注对象包含的额外属性和组建方式
构建者模式将复杂的对象的构建和表示分离，使得同样的构建过程可以创建不同的表示

### 原型模式

创建一个对象和另一个对象完全相同，将克隆的过程委派给被克隆的实际对象，被克隆的对象叫做原型
客户端在不知道具体类的情况下，通过接口管理器获取新的的实例

### 单例模式

全局只有一个实例。它负责创建自己的对象
保证全局实例的唯一性，只能被初始化一次，适合全局共享一个实例，例如数据库实例，全局配置等

- 饿汉
    - 全局的单例实例在包被加载时创建
- 懒汉
    - 全局的单例实例在被使用时候创建

### `New`

创建和初始化结构体实例，通常用于封装结构体的创建过程，提供一个包级别的函数或者方法

### 函数选项模式

用于处理函数或者对象具有多个可选参数的情况，运行用户根据需求为函数传递不同参数选项参数，定制函数的行为
又被称为傻瓜模式，常常用于参数传递，一般用户和 `New` 模式配合使用

### 对象池模式

预先实例化一定数量的对象，在需要的时从池中获取对象并在使用完成之后归还，减少对象的创建和销毁次数

- 对象池
    - 管理和维护一组对象池实例，提供对象获取和对象归还
- 对象
    - 池中存储的具体对象，可以被获取和归还
- 客户端
    - 从池中获取对象并进行操作，完成操作之后归还对象

# 行为模式

### 中介者模式

减少对象之间的直接依赖关系，促进对象之间的松耦合，所有的对象不再彼此通信

- 中介
    - 定义一个接口和各个同事对象之间通信
- 具体中介者
    - 实现中介接口，协调各个同事对象之间的通信
- 同事类
    - 每个同事类都知道中介对象，并可以通讯

### 观察者模式

定义一对多的依赖关系，让多个观察者对象同时监听并接受被观察者的对象的状态变化

- 目标
    - 被观察者
        - `Vector`存放被观察者的容器，保证线程安全
        - `attach` 添加观察者
        - `detach` 删除观察者
        - `notify` 调用观察者对象方法
- 具体目标
    - 目标的子类，通常包含经常需要发生改变的数据，状态发生变化的时候通知观察者
- 观察者
    - 对观察目标改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法
- 具体观察者
    - 维护一个指向具体目标的引用，存储具体观察者有关的状态

### 命令模式

将请求以命令的方式包裹在对象里面，传递给调用对象，调用对象寻找匹配该命令的对象，将命令交给该对象执行（排队请求，记录命令运行日志）

- 执行顺序
    - 命令被包裹在请求对象中，传递给调用对象
    - 调用对象查找匹配该命令的对象，将该命令传递给匹配的对象
    - 对象执行传递过来的命令
- 组成
    - 命令接口
        - 命令抽象成一个接口，不同的命令执行不同的操作
    - 具体命令
        - 实现命令接口，包含实际执行操作的方法
    - 调用者
        - 请求的封装发送者，通过命令对象来执行请求，不会直接操作接收者，而是直接关联命令对象
    - 接收者
        - 真正执行命令的对象
    - 客户端
        - 创建调用者，具体命令类去执行命令

### 迭代器模式

提供一种方法来顺序访问一个聚合对象中的各个元素，而无需暴露内部实现方式。迭代器模式需要将迭代操作从聚合对象中分离出来，让客户端可以独立地遍历聚合对象中的元素

- 迭代器接口
    - 定义访问和遍历元素的方法
        - `Next`
        - `HashNext`
- 具体迭代器
    - 实现迭代器接口
        - 数据
        - 列表
- 聚合对象
    - 定义创建迭代器方法
- 具体聚合对象
    - 实现聚合对象接口
        - 具体数据结构的管理和遍历

### 模板方法模式

将一个类中能够公共使用的方法抽象到抽象类中实现，不能公共使用的方法作为抽象方法，强制子类实现

### 策略模式

定义一系列算法，将算法封装起来，使得它们可以相互替换。客户端可以动态的选择需要的算法

### 状态模式

主要解决复杂状态之间的转换问题，核心目的是设计一个状态机，使用状态的改变来驱动行为的变化

- 状态接口
    - 定义通用状态规范
        - 处理请求方法 `handle()`
- 状态实现
    - 具体状态实现类，根据系统环境用于表达环境的各种状态
- 系统环境
    - 持有状态接口引用和更新状态的方法

### 备忘录模式

允许将对象在不暴露其内部状态的情况下捕获并存储这些状态，后续可以恢复到先前的这些状态
程序运行时对象的状态随时可能发生改变，当修改其状态我们可以对其进行记录（浏览器前进后退，操作系统快照恢复等操作）

- 发起人
    - 创建备忘录对象，更具需要将当前对象保存到备忘录中或者恢复备忘录中的某个状态
- 备忘录
    - 用于存储发起人的内部状态，可以包含多个状态属性，提供读取和设置
- 管理者
    - 管理备忘录对象，但是不进行操作

